<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Template for Fractal Geometry Computational Lab Reports" />
  <link rel="stylesheet" href="https://latex.vercel.app/style.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" />
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
      }
    };
  </script>
  <title>Fractal Geometry Lab Report</title> 
</head>
<body id="top">

  <header>
    <h1>Fractal Geometry Lab Report 2</h1>
    <p class="author">
      Lindsey Guinan <br />
      Feburary 21, 2025
    </p>
  </header>
  
  <div class="abstract">
    <h2>Abstract</h2>
    <p>
      In this lab, we will explore fractal geometry by utilizing recursive algorithms to generate two well-known fractals: the Dragon Curve and the Koch Snowflake. Fractals are shapes that look the same no matter how much you zoom in on them. Using Pythonâ€™s turtle graphics library, we will draw these fractals, which are made by repeating a simple rule over and over again. For the Dragon Curve, we will draw this through recursive splitting and turning and 90- degree angles repeatedly. We will create the Koch Snowflake by recursively subdividing an equilateral triangle, introducing smaller triangles at each iteration. These fractals will be drawn with increasing order of complexity, which will demonstrate how simple recursive rules and formulas can result in intricate patterns. Through this lab, we will observe the relationship between recursion and the detail of the fractal shapes in geometry. We will also gain an insight on the power of recursion in computer graphics and its application in generating fractals which displays great mathematical significance. 
      </section>

    </p>
  </div>

  <nav role="navigation" class="toc">
    <h2>Contents</h2>
    <ol>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#background">Background</a></li>
      <li><a href="#methods">Methods / Algorithm</a></li>
      <li><a href="#results">Results &amp; Analysis</a></li>
      <li><a href="#discussion">Discussion</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
      <li><a href="#references">References</a></li>
    </ol>
  </nav>

  <main>
    <article class="indent-pars">
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          Fractals and randomness play an important role in many natural and computational systems. Fractals are patterns that repeat at different scales, meaning that no matter how much you zoom in, the shape remains similar to the whole. They can be found in nature such as in snowflakes, crystals, and lightning. We will also explore random walks whcih can be used to simulate unpredictable movement. Examples of this are the way gas particles move in a container, stock market prices, and the spread of heat in solids. In this lab, we will use Python's turtle graphics to explore both fractals and randomness. We will focus on The Koch Snowflake, The Dragon Curve, and Random Walks. The Koch Snowflake is a fractal that starts as a triangle and adds smaller triangles to each side in a repeating pattern. The Dragon Curve is a fractal that bends at 90-degree angles, forming a jagged, yet structured pattern. The Random Walks will simulate random movement in two dimensions, mimicking real-world unpredictable paths. By adjusting parameters such as recursion depth and step size, we can analyze how different fractals evolve and how randomness affects movement. This lab will help us understand how simple rules can create both structured complexity and chaotic behavior. 
      <section id="background">
        <h2>Background</h2>
        <p>
          Now, we will explore the background of fractals and recursive patterns. Fractals are geometric figures that exhibit self- similarity, meaning that smaller versions of the shape appear within the larger structure. They are commonly generated using recursion, where a function repeatedly calls itself with smaller input values. A random walk is a path made up of a sequence of random steps in different directions. This is commonly used to simulate Brownian motion, which describes how microscopic particles move unpredictably in a fluid. In this lab. we will implement a random walk where a virtual turtle moves forward in random directions at each step. Over time, this creates an unpredictable, yet structured path. Applications of fractals are widely used in computer graphics, scientific modeling, and natural simulations such as computer- generated landscapes (mountains and clouds), data compresssion (fractals can help reduce image file sizes), and future modeling (river formations, lightning patterns). Randsom walks are used in physics (modeling diffusion and particle motion), finance (prediciting stock market fluctuations), and biology (studying animal movement patterns). By coding and visualizing these processes and patters, we are able to gain a deeper understanding of how mathematical concepts shape the natural and digital world. 
        </p>
      </section>

      <section id="methods">
        <h2>Methods / Algorithm</h2>
        <p>
         First, we will look at the code that simulates a random walk using Python's turtle graphics.
        </p>

        <pre><code class="language-python">!wget -O turtle_setup.py 'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py'
import random

# Step 1: Initialize the turtle canvas
canvas_width = 1000
canvas_height = 800
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')

# Step 2: Function to perform a random walk (Brownian motion)
def random_walk(steps, step_length):
    speed(0)             # Set speed to maximum for faster drawing
    penup()
    jump(450, 450)       # Start near the middle of the canvas
    pendown()

    for _ in range(steps):
        forward(step_length)               # Move forward by the step length
        right(random.uniform(-180, 180))   # Turn by a random angle between -180 and 180 degrees

# Step 3: Execute the random walk with increased steps and/or step length
steps = 1000
step_length = 10

random_walk(steps, step_length)

# Step 4: Display the result
show()

</code></pre>

        <p>Now we will look at the code that will draw a straight line with a "blip" in the middle. </p>
        <pre><code class="language-python">
        initializeTurtle()
        showturtle()

        jump(50, 400)
        face(90)


        # Line with blip
        forward(800 / 3)
        left(60)
        forward(800 / 3)
        right(120)
        forward(800 / 3)
        left(60)
        forward(800 / 3)



show()
</code></pre>
        <p>We can use the blip line that we just made and create a recursive pattern of this blip line. The previous blip line was order 1, so it had one zigzag in the middle. This recursive blip line we will create has order 2, so each zigzag has smaller zigzags inside making it more detailed. We can see from this code that higher orders will create a fractal shape.  </p>
        <pre><code class="language-python">
      # Define the blip_line function
def blip_line(length, order):
    if order == 0:
        forward(length)
    else:
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)
        right(120)
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)


initializeTurtle()

# Draw blip lines of different orders
jump(50, 400)
face(90)
color('red')
blip_line(800, 1)  # Order 1

jump(50, 350)
face(90)
color('blue')
blip_line(800, 2)  # Order 2

show()
</code></pre>
             <p>Now we can use these tools to draw a Koch Snowflake, which is a very well-known fractal pattern that resembles a snowflake. This fractal is created using recursive line divisions and turns. We can use a recursive blip line function in which the recursion repeats for each segment, making the pattern more detailed at higher orders.  </p>
        <pre><code class="language-python">
     initializeTurtle()
showturtle()

# Define the blip_line function (Koch curve)
def blip_line(length, order):
    if order == 0:
        forward(length)
    else:
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)
        right(120)
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)

# Draw the Koch snowflake
def koch_snowflake(length, order):
    for _ in range(3):
        blip_line(length, order)
        right(120)

# Set up the turtle
jump(250, 500)
face(0)
color('blue')

# Draw the snowflake
length = 400
order = 3
koch_snowflake(length, order)

show()
</code></pre>
      </section>

      <section id="results">
        <h2>Results &amp; Analysis</h2>
        <p>When we run the first code, we can see that the turtle draws a square. When we run the second part of the code, we see the results of generating a horizontal line of polygons. </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/lex.2.png?raw=true" alt="Fractal Example" width="600" height="400" loading="lazy" />
          <figcaption>Square Drawn by The Turtle.</figcaption>
        </figure>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/ex.2.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Horizontal Line of Polygons.</figcaption>
        </figure>
      </section>
    </article>
  </main>


        
      </section>

      <!-- Modifications -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="modifications">
        <h2>Modifications</h2>
        <p>
          We can modify this code and add our own touch too! We can change the background color, the size of the square the turtle draws, and changing the coordinates in which the turtle draws the square. 
        <p>I will change the background color to black, the path of the turtle to pink, and the starting position from (200,200) to (500,450). Let's look at the results! </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/myex.1.png?raw=true" alt="Fractal Example" width="600" height="400" loading="lazy" />
          <figcaption>Results of Modifications.</figcaption>
        </figure>
      </section>

      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
          In this lab, we utilized Python's turtle graphics to generate a sequence of polyogns with increasing sides, ranging from triangles to 19-sided shapes. By implementing a structured approach, we initialized a canvas, defined helper functions for color randomization and polygon drawing, and positioned the polygons in a horizontal sequence. The use of random colors added visual variety, while the incremental increase in the number of sides demonstrated the geometric transformation from simple to complex shapes.

This exercise provided insights into computational geometry, the importance of precise angle calculations, and the versatility of turtle graphics for creative visualizations. Additionally, it reinforced programming concepts such as loops, functions, and coordinate positioning. 
        </p>
      </section>





  
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
