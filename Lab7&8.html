<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Template for Fractal Geometry Computational Lab Reports" />
  <link rel="stylesheet" href="https://latex.vercel.app/style.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" />
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
      }
    };
  </script>
  <title>Fractal Geometry Lab Report</title> 
</head>
<body id="top">

  <header>
    <h1>Fractal Geometry Lab Report 7 & 8</h1>
    <p class="author">
      Lindsey Guinan <br />
      April 17, 2025
    </p>
  </header>
  
  <div class="abstract">
    <h2>Abstract</h2>
    <p>
       In this lab, we will explore fractal geometry through the exploration and visualization of the Mandelbrot and Julia sets, two fundamental constructs in complex dynamics. By using Python, NumPy, Matplotlib, and Numba, we will generate high0 resolution visualizations of these fractals. The lab will involve zooming into intricate regions of the Mandelbrot set  and observing how different complex constants affect the structure of the Julia set. We will also explore enhancements using color maps and lay the foundation for future extensions like animation. These visual experiements reveal the complexity and self-similarity characteristic of fractals, reinforcing their mathematical beauty and computational richness. 
      </section>

    </p>
  </div>

  <nav role="navigation" class="toc">
    <h2>Contents</h2>
    <ol>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#background">Background</a></li>
      <li><a href="#methods">Methods / Algorithm</a></li>
      <li><a href="#results">Results &amp; Analysis</a></li>
      <li><a href="#discussion">Discussion</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
    </ol>
  </nav>

  <main>
    <article class="indent-pars">
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
         Fractals are infinitely complex patterns that exhibit self-similarity across different scales. They are not only visually striking but also deeply connected to chaos theory, nonlinear dynamics, and complex analysis. In this lab, we focus on two prominent fractals: the Mandelbrot set and the Julia set. Both emerge from the iteration of simple complex functions and provide insight into the behavior of dynamical systems. Using Python and optimized numerical libraries, we implement algorithms to compute and visualize these sets. We will examine how changing the region of the complex plane (zooming) and modifying the iterative function's constant affects the output. Additionally, visualization techniques like varying colormaps are used to enhance interpretation and asethetics. The lab ultimately combines mathematical theory, computational methods, and visual analysis to explore the depth and beauty of fractals. 
      <section id="background">
        <h2>Background</h2>
        <p>
         The Mandelbrot and Julia sets are based on iterating a simple complex function where z is a complex number representing a point on the complex plane and c is a constant complex parameter. In the Mandelbrot set, with fix z equal to zero and vary c. For each c, we track whether the sequence remains bounded or diverges. The Mandelbrot set is the collection of all such c values for which the sequence does not escape to infinity. Its boundary exhibits intricate, infinitely detailed structure, often explored through zooming. In contrast, the Julia set fixes the value of c and varies the initial z. This creates a complex and often fragmented image where each point's color reflects how quickly its orbit diverges. Depending on the choice of the c, the Julia set can be connected or completely dissconnected (dust). In this lab, we will use NumPy, Numba, and Matplotlib. Together, these will allow us to efficiently explore fractals in high detail, experiement with parameters, and appreciate their mathematical and visual complexity. 
        </p>
      </section>

      <section id="methods">
        <h2>Methods / Algorithm</h2>
        <p>
         First, we will look at a function that draws a binary fractal tree, where each branch splits into two smaller branches, and the process repeats. This code creates a symmetrical, tree-like pattern with branching angles.
        </p>

        <pre><code class="language-python">!wget -O turtle_setup.py 'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py'
import random

# Function to draw a fractal tree using recursion
def fractal_tree(length, depth):
    if depth == 0:
        return
    else:

        forward(length)
        left(30)

        fractal_tree(length * 0.7, depth - 1)

        right(60)

        fractal_tree(length * 0.7, depth - 1)

        left(30)
        backward(length)

</code></pre>

        <p> Now we will set up the environment and execute the fractal_ tree function that we defined previously using a custom turtle graphics environment to create and display a recursive fractal tree.  </p>
        <pre><code class="language-python">
          
 # Initialize the turtle
initializeTurtle(initial_window_size=(500, 500))

# Set up the turtle's starting position and orientation
jump(250, 450)  # Starting position at the bottom center of the canvas
face(0)
color('green')  # Set the pen color

# Set the length and depth for the fractal tree
length = 100  # Initial length of the main trunk
depth = 7     # Recursion depth (number of branching levels)

# Draw the fractal tree
fractal_tree(length, depth)

# Display the drawing
show()

</code></pre>
             <p> Now, we will create a function that will draw a binary- style fractal tree in which each branch splits into two smaller branches at an angle, recursively. Unlike the fractal tree function, the build tree function offers greater control over the tree's appearance, allowing for asymmetrical or varied structures by adjusting certain features.  </p>
        <pre><code class="language-python">
   # Define the fractal tree function
def build_tree(branch_length, shorten_by, angle):
    if branch_length > 3:

        forward(branch_length)

        new_length = branch_length - shorten_by

        left(angle)

        build_tree(new_length, shorten_by, angle)

        right(angle * 2)

        build_tree(new_length, shorten_by, angle)

        left(angle)

        backward(branch_length)

</code></pre>
         <p> Lastly, we create the code that initializes the turtle and actually executes the build tree function, which outputs a green fractal tree centered at the bottom of the canvas, expanding upwards and outwards.  </p>
        <pre><code class="language-python">
          
  # Initialize the turtle
initializeTurtle(initial_window_size=(800, 800))

# Set up the turtle's starting position and orientation
jump(400, 600)  # Starting position at the bottom center of the canvas
face(0)
color('green')  # Set the pen color

# Draw the fractal tree
build_tree(80, 8, 25)

# Display the drawing
show()

</code></pre>
    
      </section>

      <section id="results">
        <h2>Results &amp; Analysis</h2>
        <p> In the first and second chunks of code, we create a function that draws a fractal tree using recursion. Let's look at the results! </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/fractal tree.png?raw=true" alt="Fractal Example" width="600" height="400" loading="lazy" />
          <figcaption>Fractal Tree</figcaption>
        </figure>
        <p> Then, we created a fractal tree function that builds a fractal tree using recursion and parameters. Let's look at the tree! </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/build tree.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption> </figcaption>
        </figure>
      </section>
    </article>
  </main>

        
      </section>

      <!-- Modifications -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="modifications">

        <h2>Modifications</h2>
        <p>
         Now, we can modify and add some code that will use this function to create a tree with flower buds on it. We can do this by defining a function to draw a simple flower and then input this function into the build tree function! Let's look at the results!
        </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/flowertree.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption> Fractal Tree With Flowers </figcaption>
        </figure>
        <p> We can also create a fractal tree of a different color, add a background color, and change the length and depth of the tree.  </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/2ndfractaltree.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption> Colorful Fractal Tree </figcaption>
        </figure>
        <p> We can also create a seasonal looking tree by changing the color of the tree and the parameters of the tree.</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/fall tree.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Halloween Tree </figcaption>
        </figure>
      </section>

      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p> Throughout this lab, we manipulated key parameters such as branch length, angle, and recursion depth to investigate their effects on the overall shape and complexity of the fractal trees. The introduction of flower patterns at the tips of the branches enhanced the visual appeal, demonstrating the versatility of recursive algorithms in creating intricate designs. Additionally, experiementing with different colors and backgrounds allowed for the simulation of seasonal variations, further enriching the visual representation. This hands- on experience reinforced the concept of recursion in computer science, highlighting its utility in modeling natural phenomena. This lab provided practical insights into the power of recursive algorithms in generating fractal structures. The iterative process of adjusting parameters and observing the resulting changes deepened our understanding of how fractal geometry applies to real- world occurrences. In summary, this lab effectively demonstrated the application of recursion in generating fractal trees, offering a visual and interactive means to comprehend the principles of fractal geometry. The experiment showcased how simple recursive rules can lead to the emergence of complex, self-similar patterns, mirroring the intricate structures found in nature, such as trees.   </p>        
      </section>





  
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
