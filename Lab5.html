<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Template for Fractal Geometry Computational Lab Reports" />
  <link rel="stylesheet" href="https://latex.vercel.app/style.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" />
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
      }
    };
  </script>
  <title>Fractal Geometry Lab Report</title> 
</head>
<body id="top">

  <header>
    <h1>Fractal Geometry Lab Report 5</h1>
    <p class="author">
      Lindsey Guinan <br />
      March 25, 2025
    </p>
  </header>
  
  <div class="abstract">
    <h2>Abstract</h2>
    <p> This lab will explore the construction and visualization of the Cantor set, a classic example of a fractal and a foundational object in mathematical analysis. Using a recursive Python function, the Cantor set it generated by repeatedly removing the middle third of a line segment at each level of recursion. The fractal will be plotted using matplotlib to illustrate its self-similarity and infinitely nested structure. This project highlights how simple recursive rules can create complex and counterintuitive geometric patterns. 
       
      </section>

    </p>
  </div>

  <nav role="navigation" class="toc">
    <h2>Contents</h2>
    <ol>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#background">Background</a></li>
      <li><a href="#methods">Methods / Algorithm</a></li>
      <li><a href="#results">Results &amp; Analysis</a></li>
      <li><a href="#discussion">Discussion</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
    </ol>
  </nav>

  <main>
    <article class="indent-pars">
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          Fractal geometry provides a framework for studying complex shapes that exhibit self-similarity across different scales. Unlike traditional Euclidean geometry, fractals often possess non- integer dimensions and arise naturally in various physcial, biological, and computational systems. One of the earliest and simplest examples of a fractal is the Cantor set, introduced by Georg Cantor in 1883. The Cantor set is formed by repeatedly removing the middle third of a line segment, producing an object that is uncontably infinite yet has zero total length. This lab shows the implementation of the Cantor set using recursive programming and visualization techniques in Python, emphasizing the conceptual beauty and mathematical richness of fractal structures. 
      <section id="background">
        <h2>Background</h2>
        <p>
        The Cantor set is a fundamental object in fractal geometry and mathematical analysis. It is constructed through an iterative process: starting with a single line segment, the middle third is removed, and the process is repeated recursively for the remaining segments. Despite its simplicity, the Cantor set exhibits many remarkable properties: it is nowhere dense, uncountable, and has a Hausdorff dimension that is less than one, and it has log(2)/log(3) dimensions. The recursive nature of the Cantor set makes it particulary suited to algorithmic generation. In this lab, Python's recursive function calls are used to model this process, and matplotlib is utilized to create a visual representation. Understanding the Cantor set provides insights into concepts like measure theory, topology, and the foundations of modern fractal mathematics.  
      <section id="methods">
        <h2>Methods / Algorithm</h2>
        <p>
         Now, we will look at the code that recursively builds the Cantor set by starting with one full bar, or the intitial segment, an then at each level, the middle third of each existing bar is removed. Then the function draws the two remaining thirds, but lower down on the figure. This process and repeated 6 times and is finally plotted to visually show the fractal.  
        </p>

        <pre><code class="language-python">!wget -O turtle_setup.py 'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py'
# Import libraries for math and plotting
import numpy as np
import matplotlib.pyplot as plt

# Set initial parameters
x_start = 0       # Starting x-coordinate of the first bar
x_end = 3         # Ending x-coordinate of the first bar
y_position = 0    # Starting y-coordinate (height of the first bar)
bar_height = 5    # Height of each bar
spacing = 10      # Space between bars (distance downwards)
depth = 6         # Number of levels to draw

# Define a function to create the Cantor Set pattern
def cantor_set(x_start, x_end, y_position, depth):
    if depth == 0:
        return []

    # Left and right segments for the current bar
    left_segment = [[x_start, x_start + (x_end - x_start) / 3, y_position]]
    right_segment = [[x_end - (x_end - x_start) / 3, x_end, y_position]]

    # Recursively generate segments for the next levels
    left_recursive = cantor_set(x_start, x_start + (x_end - x_start) / 3, y_position - spacing, depth - 1)
    right_recursive = cantor_set(x_end - (x_end - x_start) / 3, x_end, y_position - spacing, depth - 1)

    # Combine the current segments with the results from recursive calls
    return left_segment + right_segment + left_recursive + right_recursive

# Generate Cantor Set segments data
segments = np.array(cantor_set(x_start, x_end, y_position, depth))  # Convert to an array for easy plotting

# Plot the Cantor Set
plt.figure(figsize=(25, 25))

# Draw each segment as a black bar
for x_start, x_end, y in segments:
    plt.fill_between([x_start, x_end], [y] * 2, [y - bar_height] * 2, color="black")

# Hide the axes for a clean look
plt.axis('off')
plt.show()

</code></pre>
    
      </section>

      <section id="results">
        <h2>Results &amp; Analysis</h2>
        <p>Let's look at the results of the Cantor set function!  </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/cantorset.png?raw=true" alt="Fractal Example" width="600" height="400" loading="lazy" />
          <figcaption>Cantor Set Fractal</figcaption>
        </figure>
  
      </section>
    </article>
  </main>


        
      </section>

      <!-- Modifications -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="modifications">

        <h2>Modifications</h2>
        <p>
         Now, let's do some modifications and see how changing the rule and color affects the pattern of the fractal! 
        </p>
        <p> Let's try rule 52!</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule52.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 52 </figcaption>
        </figure>
        <p> Let's try rule 45!</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule45.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 45 </figcaption>
        </figure>
        <p> Let's try rule 21!</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule21.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 21 </figcaption>
        </figure>
        <p> Let's try rule 101!</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule101.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 101 </figcaption>
        </figure>
         <p> Let's try rule 150!</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule150.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 150 </figcaption>
        </figure>
      </section>

      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>In this lab, we explored fractal geometry and cellular automata through computational simulations. Our primary focus was on generating the Sierpinski Triangle, a well-known fractal, and experimenting with elementary cellular automata to observe how different rule sets influence pattern formation. We first implemented a recursive algorithm to generate the Sierpinski Triangle using the Turtle graphics library. By breaking down a large equilateral triangle into smaller self-similar triangles, we observed the fundamental property of fractals: self-similarity at different scales. Increasing the recursion depth allowed us to see finer details in the fractal structure. We then shifted to cellular automata, where we represented a simple one-dimensional system using a binary grid. The rules governing the automaton determined how each cell evolved based on its neighbors. By manipulating these rules we saw how different rule sets created vastly different patternsâ€”ranging from highly structured, fractal-like formations to chaotic, random-looking structures. Some rules (like Rule 90) naturally formed fractal patterns, while others (like Rule 45) resulted in chaotic behavior, highlighting the connection between deterministic rules and emergent order. This lab illustrated how mathematical structures can emerge from simple, recursive rules. Fractals and cellular automata reveal how complexity can arise from simplicity, a concept that is widely applicable in science, technology, and nature. </p>        
      </section>





  
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
