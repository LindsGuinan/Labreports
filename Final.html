
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Template for Fractal Geometry Computational Lab Reports" />
  <link rel="stylesheet" href="https://latex.vercel.app/style.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" />
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
      }
    };
  </script>
  <title>Fractal Geometry Lab Report</title> 
</head>
<body id="top">

  <header>
    <h1>Fractal Geometry Final</h1>
    <p class="author">
      Lindsey Guinan <br />
      April 30, 2025
    </p>
  </header>
  
  <div class="abstract">
    <h2>Abstract</h2>
    <p>
       In this final, we will investigate the generation and visualization of fractals using three different computational techniques: the Chaos Game, L-Systems, and Hilbery Curves. Each method will demonstrate how complex and self-similar structures can emerge from simple iterative processes or recursive rules. Through the use of Python programming and visualization libraries, we will explore the mathematical principles behind fractals such as the Sierpinski Triangle, Barnsley Fern, fractal trees, and space-filling curves. This final will emphasize the power of deterministic and probabilistic algorithms in producing intricate and geometrical patterns and will deepen our understanding of how fractals model natural and mathematical phenomena. 
      </section>

    </p>
  </div>

  <nav role="navigation" class="toc">
    <h2>Contents</h2>
    <ol>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#background">Background</a></li>
      <li><a href="#methods">Methods / Algorithm</a></li>
      <li><a href="#results">Results &amp; Analysis</a></li>
      <li><a href="#discussion">Discussion</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
    </ol>
  </nav>

  <main>
    <article class="indent-pars">
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
         We have learned throughout this semester that fractals are infinitely complex patterns that exhibit self-similarity at different scales. They appear in various natural and theoretical contexts, from the shapes of trees, plants, and lightning to the behavior of chaotic systems. Through this final, we will explore the mathematical generation of fractals through programming, using three core techniques. First, the Chaos Game illustrates how randomness and geometric constraints can produce order, specifically through the generation of the Sierpinski Triangle and Barnsley Fern. Second, L-Systems (Lindenmayer Systems) model the recursive nature of plant growth and are used to draw fractal trees through string rewriting and turtle graphics. Finally, the Hilbert Curve demonstrates how a simple set of recursive rules can generate a continuous curve that fills space, offering insights into dimension and spatial efficiency. Through these three parts, this final will be able to piece together theory and computation, providing a visual and algorithmic exploration of fractal geometry.  
        <h2>Background</h2>
        <p>
        Fractal geometry was formalized in the 20th century by mathematicians such as Benoît Mandelbrot, who introduced the concept to describe irregular and fragmented shapes in nature. Unlike traditional Euclidean geometry, fractals often have non-integer dimensions and are generated using recursive or iterative processes. The Chaos Game is a method that generates points based on probabilistic rules and consistently produces deterministic patterns, like the Sierpinski Triangle. Similarly, the Barnsley Fern uses affine transformations with assigned probabilities to simulate the growth of a fern-like plant. L-Systems were originally developed by Aristid Lindenmayer to model the growth of algae. They use symbolic rules to iteratively transform strings, which are then interpreted as drawing commands. These systems are especially suited for modeling branching structures like trees and plants. Hilbert Curves, on the other hand, are examples of space-filling curves. They are continuous fractal curves that pass through every point in a 2D grid without crossing themselves. Together, these methods represent diverse but interconnected approaches to understanding and constructing fractal structures through code. 

        </p>
      </section>

      <section id="methods">
        <h2>Methods / Algorithm</h2>
        <p>
         Part 1 is the Chaos Game. First we will generate the code that uses the Chaos game algorithm to generate the Sierpinski Triangle, which is a classic example of a fractal. The first part of the code is the setup, which defines three vertices of an equilateral triangle and initializes a large number of iterations. The x and y coordinates of the points are then stored in an array. The second part of this code randomly chooses an initial point within the triangle, and then we then enter the Chaos Game Loop. In the Chaos Game Loop, for each iteration, the algorithm randomly selects one of the triangle's vertices. It then finds the midpoint between that vertex and the last plotted point and this new midpoints becomes the next point to plot. This is then visualized as the code plots all points on a scatter plot. The result is the emergence of the Sierpinski Triangle, which we have studied before. 
        </p>

        <pre><code class="language-python">!wget -O turtle_setup.py 'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py'
import matplotlib.pyplot as plt
from random import random, randint
import numpy as np

def midpoint(P, Q):
    return (0.5*(P[0] + Q[0]), 0.5*(P[1] + Q[1]))

vertices = [(0, 0), (2, 2*np.sqrt(3)), (4, 0)]
iterates = 50000
x, y = [0]*iterates, [0]*iterates
x[0], y[0] = random(), random()

for i in range(1, iterates):

    k = randint(0, 2)

    x[i], y[i] = midpoint( vertices[k], (x[i-1], y[i-1]) )

plt.figure(figsize=(8, 8))
plt.scatter(x, y, color = 'b', s=0.1)
plt.title('Sierpinski Triangle Generated Using the Chaos Game')
plt.axis('equal')  # Ensure aspect ratio is equal for an equilateral triangle
plt.show()

</code></pre>

        <p>In the next part of Part 1, we will look at the code that generates the Barnsley Fern, another well-know fractal. We will do this using a method based on iterated function systems. This system works by transformation functions, as four affine transformations are defined and each function transforms a point (x,y) in a different way. These transformation model how different parts of a fern leaf are scaled, rotated, and translated. Each function has a probability associated with it, determining how often it's applied during the iteration process. Then starting from the origin, the code randomly selects a transformation function based on the given probabilities and applies it to generate a new point. This process is repeated 100,000 times, and each new point is stored. All generated points are plotted using a scatter plot and the final output is a realistic fractal image of a fern, showcasing self-similarity and natural complexity.    </p>
        <pre><code class="language-python">
import random
import matplotlib.pyplot as plt

# Define the transformation functions
def f1(x, y):
    x = 0
    y = 0.16 * y
    return x, y

def f2(x, y):
    x_new = 0.85 * x + 0.04 * y
    y_new = -0.04 * x + 0.85 * y + 1.6
    return x_new, y_new

def f3(x, y):
    x_new = 0.2 * x - 0.26 * y
    y_new = 0.23 * x + 0.22 * y + 1.6
    return x_new, y_new

def f4(x, y):
    x_new = -0.15 * x + 0.28 * y
    y_new = 0.26 * x + 0.24 * y + 0.44
    return x_new, y_new

# Probabilities for each function
probabilities = [0.01, 0.85, 0.07, 0.07]

# Barnsley Fern function
def barnsley_fern(iterations):
    x, y = 0, 0
    points = []

    for _ in range(iterations):
        rand = random.random()
        if rand   < sum(probabilities[:1]):
            x, y = f1(x, y)
        elif rand < sum(probabilities[:2]):
            x, y = f2(x, y)
        elif rand < sum(probabilities[:3]):
            x, y = f3(x, y)
        else:
            x, y = f4(x, y)

        points.append((x, y))

    return points

# Generate points for the Barnsley Fern
iterations = 100000
fern_points = barnsley_fern(iterations)

# Plot the Barnsley Fern
x_vals, y_vals = zip(*fern_points)
plt.figure(figsize=(6, 10))
plt.scatter(x_vals, y_vals, s=0.1, color='green')
plt.title('Barnsley Fern')
plt.show()


</code></pre>
             <p> Part 2 is called L-Systems. We will now look at the code that uses an L-System with turtal graphics to draw a fractal tree. It works by first initializing the turtle graphics environment. Then the L-System is generated and defined with an axiom ('F') and a rewrite rule. This rule recursively replaces every 'F' with a longer string over 4 iterations, generating a complex command string. The draw_lsystem function interprets the generated string using turtle commands. The turtle starts at a specified location and draws the structure using green color, step size, and angle. The final drawing is a recursive, self-similar tree structure that mimics the branching patterns of natural trees.    </p>
        <pre><code class="language-python">
 # Initialize the turtle
initializeTurtle()
showturtle()

# Function to apply L-system rules
def apply_rule(char, rules):
    return rules.get(char, char)

# Function to generate L-system string
def generate_lsystem(axiom, rules, iterations):
    current_string = axiom
    for _ in range(iterations):
        current_string = ''.join([apply_rule(char, rules) for char in current_string])
    return current_string

# Function to draw the L-system with turtle
def draw_lsystem(turtle_string, length, angle):
    stack = []
    for command in turtle_string:
        if command == 'F':
            forward(length)
        elif command == '+':
            left(angle)
        elif command == '-':
            right(angle)
        elif command == '[':
            position = (getx(), gety())
            heading_angle = heading()
            stack.append((position, heading_angle))
        elif command == ']':
            position, heading_angle = stack.pop()
            jump(position[0], position[1])
            face(heading_angle)

# Define the L-system rules
rules = {'F': 'FF+[+F-F-F]-[-F+F+F]'}

axiom = 'F'
iterations = 4

# Generate the L-system string
turtle_string = generate_lsystem(axiom, rules, iterations)

# Set up the turtle
jump(400, 500)
face(0)
color('green')

# Draw the L-system fractal tree
length = 8
angle = 25
draw_lsystem(turtle_string, length, angle)

# Display the drawing
show()


</code></pre>
         <p>Next, we will introduce the code for the cellular automata. In this chunk of code, we will import NumPy and Matplotlib and define a function plot(x) for visualizing a 2d array. We will then generate a 100x100 grid initialized with zeros. It will set the element at position (0,50) to 1, effectively placing a white pixel in the grid at that location while keeping all other pixels black. The plot(C) function then visualizes this grid as a grayscale image using matplotlib. After this, we have a code that takes an integer value 90 and converts it into an 8-bit binary representation using Python's string syntax. </p>
        <pre><code class="language-python">
      import numpy as np
import matplotlib.pyplot as plt
#visualizing a 2d array
def plot(x):
    fig, ax = plt.subplots()
    im = ax.imshow(x, cmap = 'gray')
    ax.axis('off')
    fig.set_size_inches(10, 10)
    plt.show()
#generate a 100x100 grid of zeros 
    C = np.zeros((100,100)).astype(int)
C[0,50] = 1
plot(C)
#converting integer number 90 into an 8- bit binary representation 
    num = 90
print(f'{num:08b}')

</code></pre>
         <p>Now, we can create and modify a 3D array called rule. This array represents a rule table for a cellular automaton, where each 3D index corresponds to a combination of neighboring cells and the rule specifies what the central cell should be based on its neighboring cells. This rule can be used in the cellular automaton algorithm to determine the next state of a grid based on the surrounding states.  </p>
        <pre><code class="language-python">
   rule = np.zeros((2,2,2))

rule[0,0,0] = 0
rule[0,0,1] = 1
rule[0,1,0] = 0
rule[0,1,1] = 1
rule[1,0,0] = 1
rule[1,0,1] = 0
rule[1,1,0] = 1
rule[1,1,1] = 0

</code></pre>
       <p> Using this new rule, we can now create a function that applies a 1D cellular automation rule (like rule 90, rule 30, etc.) to each row  based on the previous row's value. This is a common method used for generating patterns and fractals in cellular automata. The rule table defines how a new cell state is determined from its three upper neighborhoods. We can then generate and display a visual pattern based on the cellular automaton rule applied to the grid C, which was previously defined.    </p>
        <pre><code class="language-python">
    #Define the function 
    def CA(X):

    for i in range(1,X.shape[0]-1): #row
        for j in range(1,X.shape[1]-1): #col

            N  = X[i-1,j]
            NW = X[i-1,j-1]
            NE = X[i-1,j+1]

            X[i,j] = rule[NW,N,NE]

    return X
    #Create visual pattern
    plot(CA(C))
</code></pre>
        <p> Finally, we can create a chunck of code that applies the rule 90 to a 2D grid, uses the three upper neighbors to compute the next state of each cell, generates a fractal pattern called the sierpinski triangle, and displays the structure using plot. Lastly, we can run multiple cellular automaton simulations using different rules. This will generate and display a visualization of the evolving patterns for each rule and gives us insight on how different rules affect pattern formation in cellular automata, which reveals complex behaviors for simple rules.     </p>
        <pre><code class="language-python">
   #Function for generating fractal pattern       
   def CA(X):

    for i in range(1,X.shape[0]-1): #row
        for j in range(1,X.shape[1]-1): #col

            X[i,j] = (rule/(2**(4*X[i-1,j-1] + 2*X[i-1,j] + X[i-1,j+1]))) % 2

    return X

rule = 90

plot(CA(C))

#Rule for running multiple cellular automaton simulations using different rules
  for rule in [30, 62, 90, 110, 126]:
    plot(CA(C))
</code></pre>
    
      </section>

      <section id="results">
        <h2>Results &amp; Analysis</h2>
        <p>In the first chunk of code, we define a function to draw an equilateral triangle. This function is then used to tell the turtle to draw an equilateral triangle. Let's look at the results!  </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/triangle.png?raw=true" alt="Fractal Example" width="600" height="400" loading="lazy" />
          <figcaption>Drawing of Equilateral Triangle</figcaption>
        </figure>
        <p> Next, we define a recursive Sierpinski triangle function and then initialize the turtle to draw this triangle based on the recursive function. </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/triangle2.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>The Sierpinski Triangle </figcaption>
        </figure>
         </figure>
        <p> Now, we will enter the topic of cellular automata where we define a function plot(x) for visualizing a 2D array. We will generate a 100x100 grid initialized with zeros. It will set the element at position (0,50) to 1, effectively placing a white pixel in the grid at that location while keeping all other pixels black. </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/pixel.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automata Grid </figcaption>
        </figure>
         <p> We then define a rule and use that rule to define the function that applies a 1D cellular automaton rule to each row based on the previous row's value.</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/fractal.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Fractal Generated by Using Cellular Automata </figcaption>
        </figure>
          <p> When we apply rule 90 to a 2D grid we can see the resulting Sierpinski triangle! </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/triangle3.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Sierpinski Triangle </figcaption>
        </figure>
            <p> Lastly, we can see the results of different rules. First, let's look at the result of using rule 30. Rule 30 generates a chaotic pattern which can be used in randomness and cryptography.</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule30.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 30  </figcaption>
        </figure>
          <p> Rule 62 generates a complex asymmetric pattern</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule62.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 62 </figcaption>
        </figure>
         <p> Rule 90 generates a Sierpinski Triangle</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule 90.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 90 </figcaption>
        </figure>
        <p> Rule 110 is capable of universal computation</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule110.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 110 </figcaption>
        </figure>
        <p> Rule 126 produces a fractal- like structure</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule126.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 126 </figcaption>
        </figure>
      </section>
    </article>
  </main>


        
      </section>

      <!-- Modifications -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="modifications">

        <h2>Modifications</h2>
        <p>
         Now, let's do some modifications and see how changing the rule and color affects the pattern of the fractal! 
        </p>
        <p> Let's try rule 52!</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule52.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 52 </figcaption>
        </figure>
        <p> Let's try rule 45!</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule45.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 45 </figcaption>
        </figure>
        <p> Let's try rule 21!</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule21.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 21 </figcaption>
        </figure>
        <p> Let's try rule 101!</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule101.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 101 </figcaption>
        </figure>
         <p> Let's try rule 150!</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/rule150.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Cellular Automaton Using Rule 150 </figcaption>
        </figure>
      </section>

      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>In this lab, we explored fractal geometry and cellular automata through computational simulations. Our primary focus was on generating the Sierpinski Triangle, a well-known fractal, and experimenting with elementary cellular automata to observe how different rule sets influence pattern formation. We first implemented a recursive algorithm to generate the Sierpinski Triangle using the Turtle graphics library. By breaking down a large equilateral triangle into smaller self-similar triangles, we observed the fundamental property of fractals: self-similarity at different scales. Increasing the recursion depth allowed us to see finer details in the fractal structure. We then shifted to cellular automata, where we represented a simple one-dimensional system using a binary grid. The rules governing the automaton determined how each cell evolved based on its neighbors. By manipulating these rules we saw how different rule sets created vastly different patterns—ranging from highly structured, fractal-like formations to chaotic, random-looking structures. Some rules (like Rule 90) naturally formed fractal patterns, while others (like Rule 45) resulted in chaotic behavior, highlighting the connection between deterministic rules and emergent order. This lab illustrated how mathematical structures can emerge from simple, recursive rules. Fractals and cellular automata reveal how complexity can arise from simplicity, a concept that is widely applicable in science, technology, and nature. </p>        
      </section>





  
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
