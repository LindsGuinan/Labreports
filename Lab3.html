<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Template for Fractal Geometry Computational Lab Reports" />
  <link rel="stylesheet" href="https://latex.vercel.app/style.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" />
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
      }
    };
  </script>
  <title>Fractal Geometry Lab Report</title> 
</head>
<body id="top">

  <header>
    <h1>Fractal Geometry Lab Report 3</h1>
    <p class="author">
      Lindsey Guinan <br />
      Feburary 26, 2025
    </p>
  </header>
  
  <div class="abstract">
    <h2>Abstract</h2>
    <p>
       This lab explores the concepts of fractals and cellular automata by implementing the Sierpinski triangle and simulating various cellular automaton rules. The Sierpinski triangle, a well-known fractal, is generated recursively using Turtle graphics, demonstrating the self-similarity and recursive nature of fractals. Additionally, the lab investigates the behavior of cellular automata, specifically focusing on Rule 90 and other rules like Rule 30, Rule 62, Rule 110, and Rule 126, applied to a 2D grid. The resulting patterns were visualized using NumPy and Matplotlib. Through this experiment, we observe the emergence of complex patterns from simple rules and gain insights into the fundamental principles of fractals and automata.
      </section>

    </p>
  </div>

  <nav role="navigation" class="toc">
    <h2>Contents</h2>
    <ol>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#background">Background</a></li>
      <li><a href="#methods">Methods / Algorithm</a></li>
      <li><a href="#results">Results &amp; Analysis</a></li>
      <li><a href="#discussion">Discussion</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
    </ol>
  </nav>

  <main>
    <article class="indent-pars">
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          Fractal geometry studies shapes and patterns that exhibit self-similarity at different scales, meaning the structure of the whole is repeated in parts. One classic example of such self-similarity is the Sierpinski triangle, a fractal that can be constructed by recursively subdividing an equilateral triangle into smaller equilateral triangles, removing the central triangle at each iteration. This process illustrates the concept of recursion, where a geometric shape is repeatedly divided into similar smaller parts. In addition to fractals, cellular automata (CA) are mathematical models that evolve based on local interaction rules. These systems are discrete in time and space, where each cell in a grid changes state based on the states of its neighboring cells. Cellular automata have applications in various fields, including physics, biology, and computer science, as they can model complex, emergent behaviors from simple local rules. In this lab, we utilize the Turtle graphics library to draw the Sierpinski triangle and apply cellular automaton rules, specifically Rule 90, which generates fractal-like patterns in a 1D grid. We also explore the behavior of several other cellular automaton rules, such as Rule 30, Rule 62, Rule 110, and Rule 126, and visualize the patterns they produce on a 2D grid using NumPy and Matplotlib.
      <section id="background">
        <h2>Background</h2>
        <p>
         Fractals are geometric shapes that are self-similar at various levels of magnification. This self-similarity means that smaller portions of the shape resemble the whole. The Sierpinski triangle is one of the most famous fractals, constructed through a recursive process. It begins with an equilateral triangle and recursively removes the central triangle from each resulting smaller triangle. This process, when repeated infinitely, results in a shape with intricate, repeating patterns that are similar at every scale. The Sierpinski triangle is a visual representation of recursive iteration, where each iteration follows a simple rule that generates a smaller version of the initial shape. In this lab, we use Turtle graphics, a Python module for drawing shapes, to visualize the process of generating the Sierpinski triangle. The recursive nature of the algorithm highlights the fundamental property of fractals: self-similarity. Cellular automata (CA) are mathematical models that simulate how a grid of cells evolves over discrete time steps based on local rules. Each cell can be in one of a finite number of states, and the state of each cell is updated based on the states of its neighbors. Cellular automata have been used to model a wide range of phenomena, from biological processes like the growth of plants to physical systems like fluid dynamics.
        </p>
      </section>

      <section id="methods">
        <h2>Methods / Algorithm</h2>
        <p>
         First, we will look at the code that tells the turtle to draw an equilateral triangle. 
        </p>

        <pre><code class="language-python">!wget -O turtle_setup.py 'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py'
import random

# Define the function to draw an equilateral triangle
def draw_triangle(length):
    for _ in range(3):
        forward(length)
        left(120)

</code></pre>

        <p> Now we can define a recursive function to draw a sierpinski triangle, which is a fractal pattern made up of smaller equilateral triangles. </p>
        <pre><code class="language-python">
   # Define the recursive Sierpinski triangle function
def sierpinski_triangle(length, order):
    if order == 0:
        draw_triangle(length)
    else:
        sierpinski_triangle(length / 2, order - 1)
        forward(length / 2)
        sierpinski_triangle(length / 2, order - 1)
        backward(length / 2)
        left(60)
        forward(length / 2)
        right(60)
        sierpinski_triangle(length / 2, order - 1)
        left(60)
        backward(length / 2)
        right(60)

</code></pre>
             <p>Now we can use these tools to draw a Koch Snowflake, which is a very well-known fractal pattern that resembles a snowflake. This fractal is created using recursive line divisions and turns. We can use a recursive blip line function in which the recursion repeats for each segment, making the pattern more detailed at higher orders.  </p>
        <pre><code class="language-python">
     initializeTurtle()
showturtle()

# Define the blip_line function (Koch curve)
def blip_line(length, order):
    if order == 0:
        forward(length)
    else:
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)
        right(120)
        blip_line(length / 3, order - 1)
        left(60)
        blip_line(length / 3, order - 1)

# Draw the Koch snowflake
def koch_snowflake(length, order):
    for _ in range(3):
        blip_line(length, order)
        right(120)

# Set up the turtle
jump(250, 500)
face(0)
color('blue')

# Draw the snowflake
length = 400
order = 3
koch_snowflake(length, order)

show()
</code></pre>
         <p>Now we will draw the Dragon Curve! At each recursion level of this function, the shape folds upon itself at a 90-degree angle.  </p>
        <pre><code class="language-python">
       # Define the dragon curve function
def dragon_curve(order, length, turn_direction):
    # Base case: if order is 0, just move forward
    if order == 0:
        forward(length)
    else:
        # Calculate the new length for each recursive step
        new_length = length / (2 ** 0.5)

        # Recursively draw the dragon curve, turning right and left as needed
        dragon_curve(order - 1, new_length, 1)  # First segment
        right(turn_direction * 90)             # Turn by 90 degrees
        dragon_curve(order - 1, new_length, -1) # Second segment

# Initialize the turtle for drawing
initializeTurtle()
showturtle()


# Move the turtle to a starting position
jump(400, 400)
face(0)             # Set starting direction
color('purple')     # Choose a color

# Draw the dragon curve
order = 10          # Complexity level
length = 300        # Initial length of each segment
dragon_curve(order, length, 1)

# Show the final drawing
show()

</code></pre>
      </section>

      <section id="results">
        <h2>Results &amp; Analysis</h2>
        <p>When we run the first code, the turtle starts at (450,450) and moves 1000 steps of 10 pixels each. After each step, it turns in a random direction. The resulting path is chaotic and unpredictable, similar to how tiny particals move in a fluid.   </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/random walk.png?raw=true" alt="Fractal Example" width="600" height="400" loading="lazy" />
          <figcaption>A Random Walk</figcaption>
        </figure>
        <p> When we run the second code, we can see the results of a line with a "blip". </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/blipline.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Blip Line </figcaption>
        </figure>
         </figure>
        <p> When we run the third code, we can see the results of a recursive blip line. As the function is called with a higher order, the pattern becomes more complex. We saw that the order 1 curve in the previous figure had one zigzag in the middle. This blip line is of order 2 and has smaller zigzags inside of each zigzag, making it more detailed. </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/2ndorderblipline.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Recursive Blip Line </figcaption>
        </figure>
         <p> When we run the fourth chunk of code, we can see the results of a "blip line" of order 3 which draws a higher- order Koch Curve! </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/kochcurve.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Blip Line of Order 3/ Higher- Order Koch Curve </figcaption>
        </figure>
          <p> When we run the fifth chunk of code, we can see the result of the Koch Snowflake Fractal. In this function, at order 0 the shape is a simple triangle. At order 1 each side divides into four smaller segments with a peak in the middle. At order 2 the new segments also divide into four, making the pattern more complex. Lastly at otder 3 the shape resembles a snowflake, with highly detailed edges.  </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/kochsnowflake.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Blip Line of Order 3/ Higher- Order Koch Curve </figcaption>
        </figure>
            <p> When we run the last chunk of code, we can see the result of drawing the Dragon Curve. This function creates a repreating folding process which is what gives the Dragon Curve its characteristic shape. At order 0: the structure is a straight line, at order 1: two segments form a right angle, at order 2: a more complex shape, with another right- angle fold, at order 3 and higher: the curve begins to form a unique, non- overlapping pattern, and finally at order 10 the final image is an intricate Dragon Curve.  </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/dragoncurve.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>The Dragon Curve </figcaption>
        </figure>
      </section>
    </article>
  </main>


        
      </section>

      <!-- Modifications -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="modifications">
        <h2>Modifications</h2>
        <p>
          Now, let's experiment and see how the modifications we make change the fractals. 
           <p>Let's look at the results when we modify the Recursive Blip Line by changing the color of the two lines, changing the order of the bottom line from 1 to 2 and the top one from 2 to 4, and changing the jump.   </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/myrecursive.png?raw=true" alt="Fractal Example" width="600" height="400" loading="lazy" />
          <figcaption>My Blip Line!</figcaption>
        </figure>
            <p>Let's look at the results when we modify the Koch Snowflake by changing the color from blue to purple, changing the position of the snowflake, changing the length from 300 to 100, and the order from 10 to 8!  </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/mykochcurve.png?raw=true" alt="Fractal Example" width="600" height="400" loading="lazy" />
          <figcaption>My Koch Snowflake!</figcaption>
        </figure>
        <p>Let's look at the results when we change the color of the Dragon Curve to pink, the order from 10 to 13, and the jump fron (400,400) to (300,300)! </p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/dragoncurve2.png?raw=true" alt="Fractal Example" width="600" height="400" loading="lazy" />
          <figcaption>My Dragon Curve!</figcaption>
        </figure>
      </section>

      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
          In this lab, we explored the construction of various fractal and recursive patterns using Python's Turtle Graphics. Through the implementation of the Koch Curve, Dragon Curve, and random walk simulations, we gained insight on how recursion, randomness, and geometric transformations can create intricate and visually compelling designs. By modifying the base shapes and recursion depth, we observed how changes in the rules can significantly alter the complexity and appearance of the different fractals. We also learned that the higher the order, the more complex the fractal will be. We began by experimenting with basic line transformation, such as the Blip Line, which introduced the fundamental concept of breaking a segment into smaller recursive parts. Expanding on this, we generated the Koch Snowflake, learning how fractal growth can transform a simple triangle into a highly detailed shape. Further, we explored random walks, which demonstrated how randomness influences movement patterns and diffusion. Finally, we constructed the Dragon Curve which showed us how self- similar recursive structures can create complex, space- filling curves. This lab deepened our understanding of recursive functions and iterative geometric transformations, reinforcing key programming concepts such as function calls, loops, and conditional structures. Additionally, it demonstrated the power of recursion and randomness in generating mathematical art, bridging the gap between programming and visual creativity. 
        </p>
      </section>





  
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
