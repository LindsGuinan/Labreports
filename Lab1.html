<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Template for Fractal Geometry Computational Lab Reports" />
  <link rel="stylesheet" href="https://latex.vercel.app/style.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" />
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
      }
    };
  </script>
  <title>Fractal Geometry Lab Report</title> 
</head>
<body id="top">

  <header>
    <h1>Fractal Geometry Lab Report</h1>
    <p class="author">
      Lindsey Guinan <br />
      February 17, 2025
    </p>
  </header>
  
  <div class="abstract">
    <h2>Abstract</h2>
    <p>
      In this lab report, we investigate Python's Turtle Graphics module to draw a simple square. This experiment explores programming concepts such as loops, function calls, and coordinate-based movement. By using the Turtle library in Python, we generate a square through a sequence of forward and turn commands. This experiment demonstrates the basics of drawing.
    </p>
  </div>

  <nav role="navigation" class="toc">
    <h2>Contents</h2>
    <ol>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#background">Background</a></li>
      <li><a href="#methods">Methods / Algorithm</a></li>
      <li><a href="#results">Results &amp; Analysis</a></li>
      <li><a href="#discussion">Discussion</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
      <li><a href="#references">References</a></li>
      <li><a href="#appendix">Appendix</a></li>
    </ol>
  </nav>

  <main>
    <article class="indent-pars">
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          In this lab, we explore the basics of using the Turtle module in Python to create graphics. Turtle graphics provide an intuitive way to draw shapes by controlling a virtual turtle with movement and drawing commands. The primary objective is to initialize a turtle, customize its color and background, and move it to a suitable starting position. We will use simple commands to draw a square and learn how to manipulate the turtle’s properties for more complex graphics. This lab introduces Python programming and concepts such as loops, functions, and coordinate-based movement.
        </p>
      </section>

      <section id="background">
        <h2>Background</h2>
        <p>
          Python's Turtle module is used to teach programming through visual representation. It helps beginners understand fundamental programming concepts like loops, functions, and coordinate-based movement. Simple commands allow users to manipulate the turtle’s position, direction, and appearance to create various shapes and patterns.
        </p>
      </section>

      <section id="methods">
        <h2>Methods / Algorithm</h2>
        <p>
          Below is our Python code that imports the Turtle package, initializes the turtle, sets its color and background color, and starts moving it.
        </p>

        <pre><code class="language-python">!wget -O turtle_setup.py 'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py'
from turtle_setup import *
# Initialize the turtle
initializeTurtle()
showturtle()
color('blue')
bgcolor('white')

# Move to a suitable starting position
jump(200, 200)  # Adjust these values as needed
face(0)  # Ensures the turtle is facing up

forward(100)

# Display the drawing
show()</code></pre>

        <p>We then extend these steps to draw polygons with the turtle.</p>
        <pre><code class="language-python"># Step 1: Initialize the turtle canvas
canvas_width = 1000
canvas_height = 800
initializeTurtle(initial_window_size=(canvas_width, canvas_height), mode='auto')

# Step 2: Set up helper functions
import random

def random_color():
    return color_rgb(random.random(), random.random(), random.random())

def draw_polygon(n_sides, side_length):
    angle = 360 / n_sides
    for _ in range(n_sides):
        forward(side_length)
        right(angle)

# Step 3: Draw a horizontal line of polygons
start_x, start_y = 100, 300
jump(start_x, start_y)

side_length = 20
spacing = 20

for n_sides in range(3, 20):
    color(random_color())
    draw_polygon(n_sides, side_length)
    penup()
    jump(getx() + spacing + side_length, start_y)
    pendown()

show()</code></pre>
      </section>

      <section id="results">
        <h2>Results &amp; Analysis</h2>
        <p>After running the code, we observe the results and modify factors to produce custom Turtle graphics.</p>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/fractal_ex.png?raw=true" alt="Fractal Example" width="600" height="400" loading="lazy" />
          <figcaption>Initial turtle setup.</figcaption>
        </figure>
        <figure>
          <img src="https://github.com/LindsGuinan/Labreports/blob/main/ex.2.png?raw=true" alt="Square Drawing" width="600" height="400" loading="lazy" />
          <figcaption>Square drawn by the turtle.</figcaption>
        </figure>
      </section>
    </article>
  </main>


        
      </section>

      <!-- DISCUSSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="discussion">
        <h2>Discussion</h2>
        <p>
          Using this JIT-optimized approach greatly speeds up the iterative 
          calculations needed to classify points in the set. The Mandelbrot set 
          itself highlights fundamental properties of complex quadratic polynomials: 
          small changes in the initial parameter $c$ can lead to drastic differences 
          in convergence or divergence. The zoomed region showcases the fractal’s 
          infinite detail and how parameter tuning (like increasing max_iter) 
          helps reveal more intricate structures.
        </p>
        <p>
          In practice, generating very deep zooms can become computationally expensive. 
          Techniques such as arbitrary precision arithmetic, adaptive iteration 
          strategies, and parallel/GPU-based solutions can push these explorations 
          to extreme magnifications, unveiling ever more complex filigree along 
          the Mandelbrot boundary.
        </p>
      </section>

      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
          In this lab, we leveraged a JIT-optimized code in Python to generate 
          both a broad and a zoomed-in view of the Mandelbrot set. We observed 
          the set’s hallmark “cardioid” shape at lower iteration counts 
          and uncovered increasingly intricate structures as we zoomed in 
          and raised the iteration limit. This exercise illustrates the 
          interplay between iteration depth, resolution, and performance, 
          and demonstrates how even a simple quadratic function in the complex 
          plane can generate one of the most fascinating structures in mathematics.
        </p>
      </section>

      <!-- REFERENCES SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="references">
        <h2>References</h2>
        <p>
          The following references were consulted during the preparation of this lab:
        </p>
        <ol>
          <li>
            Mandelbrot, B. <em>The Fractal Geometry of Nature</em>. 
            W. H. Freeman, 1982.
          </li>
          <li>
            Peitgen, H.-O., Jürgens, H., &amp; Saupe, D. 
            <em>Chaos and Fractals: New Frontiers of Science</em>. Springer, 1992.
          </li>
          <li>
            Devaney, R. L. <em>A First Course in Chaotic Dynamical Systems</em>. 
            Addison-Wesley, 1992.
          </li>
        </ol>
      </section>

      <!-- APPENDIX (OPTIONAL) -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="appendix">
        <h2>Appendix</h2>
        <p>
          Additional examples, larger images, or extended code listings 
          could be placed here if needed. For instance, one could include 
          higher-resolution renderings of deeper zooms or compare different 
          coloring schemes.
        </p>
      </section>
    </article>
  </main>





  
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
